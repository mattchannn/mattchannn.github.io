<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.83.1"><link rel=icon href=/images/blog-logo.png><title>為何要override Objects的equals 和hashCode method | Mat's Blog</title><meta name=description content="Matt's Blog is a blog that is powered by HUGO, which provides blog posts and technical documentation"><meta name=twitter:card content="summary"><meta name=twitter:title content="為何要override Objects的equals 和hashCode method"><meta name=twitter:description content="為何要override Objects的equals 和hashCode method 你可曾有想過 在建構新class 新object的時候，為何我們要覆寫(override) Java/Lang/Object 中的equals 和hashCode方法(method)?
在開始之前，我們必先知道原本的方法是在實現什麼東西。
Equals // Java Lang Object public boolean equals(Object obj) { return (this == obj); } Equals會將兩個object的memory address比較， 如果相等， 回傳true。 簡單來說，當你instantiate 兩個不同object的時候， 儘管它們的數值一樣，該方法都會回傳false。"><meta property="og:title" content="為何要override Objects的equals 和hashCode method"><meta property="og:description" content="為何要override Objects的equals 和hashCode method 你可曾有想過 在建構新class 新object的時候，為何我們要覆寫(override) Java/Lang/Object 中的equals 和hashCode方法(method)?
在開始之前，我們必先知道原本的方法是在實現什麼東西。
Equals // Java Lang Object public boolean equals(Object obj) { return (this == obj); } Equals會將兩個object的memory address比較， 如果相等， 回傳true。 簡單來說，當你instantiate 兩個不同object的時候， 儘管它們的數值一樣，該方法都會回傳false。"><meta property="og:type" content="article"><meta property="og:url" content="https://mattchannn.github.io/blog/2021-06/java-object-equals-hashcode/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2021-06-01T19:00:00+08:00"><meta property="article:modified_time" content="2021-06-01T18:00:00+08:00"><link href=https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css rel=stylesheet integrity=sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.0.13/css/all.css integrity=sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp crossorigin=anonymous><link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.4.1/font/bootstrap-icons.css><link href=/css/medium.css rel=stylesheet><link href=/css/additional.css rel=stylesheet><link href=/css/list.css rel=stylesheet></head><body><nav class="navbar navbar-expand-lg navbar-light fixed-top mediumnavigation nav-down"><div class="container pr-0"><a class=navbar-brand href=https://mattchannn.github.io/><img src=/images/blog-logo.png alt=logo></a>
<button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarMediumish aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarMediumish><ul class="navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=/blog>Blog</a></li><li class=nav-item><a class=nav-link href=/documentation>Doc</a></li></ul></div></div></nav><div class=site-content><div class=container><div class="main-content singe-page"><div class=container><div class=row><div class="flex-first flex-md-unordered col-md-12"><div class="addthis_inline_share_toolbox mainheading"><div class="row post-top-meta"><div class="col-xs-12 col-md-3 col-lg-2 text-center text-md-left mb-4 mb-md-0 md-nopad-right"><img class=author-thumb src=/images/author.png alt="Mat CHAN"></div><div class="col-xs-12 col-md-9 col-lg-10 text-center text-md-left md-nopad-left"><a target=_blank class=link-dark>Mat CHAN</a><br><span class=author-description>Author<br><i class="bi bi-calendar-month-fill"></i> Jun 1, 2021<i class="far fa-clock clock bi bi-clock-fill"></i> 1 min read</span></div></div></div><div class=article-post><h1 id=為何要override-objects的equals-和hashcode-method>為何要override Objects的equals 和hashCode method</h1><p>你可曾有想過 在建構新class 新object的時候，為何我們要覆寫(override) Java/Lang/Object 中的equals 和hashCode方法(method)?</p><p>在開始之前，我們必先知道原本的方法是在實現什麼東西。</p><h3 id=equals>Equals</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>// Java Lang Object
public boolean equals<span style=color:#f92672>(</span>Object obj<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>return</span> <span style=color:#f92672>(</span>this <span style=color:#f92672>==</span> obj<span style=color:#f92672>)</span>;
<span style=color:#f92672>}</span>
</code></pre></div><p>Equals會將兩個object的memory address比較， 如果相等， 回傳true。
簡單來說，當你instantiate 兩個不同object的時候， 儘管它們的數值一樣，該方法都會回傳false。</p><p>Employee.java</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>public class Employee <span style=color:#f92672>{</span>
    private Integer id;
    private String firstname;
    private String lastName;
    private String department;
    
    public void setId<span style=color:#f92672>(</span>Integer id<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        this.id <span style=color:#f92672>=</span> id;
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>Main.java</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>&lt;-- 省略 --&gt;
Employee e1 <span style=color:#f92672>=</span> new Employee<span style=color:#f92672>()</span>;
Employee e2 <span style=color:#f92672>=</span> new Employee<span style=color:#f92672>()</span>;

e1.setId<span style=color:#f92672>(</span>100<span style=color:#f92672>)</span>;
e2.setId<span style=color:#f92672>(</span>100<span style=color:#f92672>)</span>;

System.out.println<span style=color:#f92672>(</span>e1.equals<span style=color:#f92672>(</span>e2<span style=color:#f92672>))</span>;  // true
</code></pre></div><h3 id=hashcode>hashCode</h3><p>hashCode方面，它則會根據物件(object)的memory address去生成一個Integer value。而同樣地，如果兩者的memory address一樣，hashcode也會一樣。</p><h3 id=為何要override-equals>為何要override equals()</h3><p>最簡單的解釋，就是我們不想只比較兩者的reference equality (即等於比較memory address) 而希望檢查logical equality (值的相等)。
再直接點說，你其實希望有你心目中的比較方式。</p><h3 id=為何要override-hashcode>為何要override hashCode()</h3><p>如果equals方法被覆寫而hashCode方法沒有，hash-based的物件 (例如: HashMap, HashSet, HashTable) 就會表現異常。</p><p>承上</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>Set&lt;Employee&gt; employees <span style=color:#f92672>=</span> new HashSet&lt;&gt;<span style=color:#f92672>()</span>;

employees.add<span style=color:#f92672>(</span>e1<span style=color:#f92672>)</span>;
employees.add<span style=color:#f92672>(</span>e2<span style=color:#f92672>)</span>;
</code></pre></div><p>如果使用debug mode去查看employees，你會發現有兩個重複的object被insert進去，編者估計原因是即使現在比較兩個object的logic已經被覆寫。</p><p>但基誨hashCode的方法沒有被覆寫，而導致兩個值一樣的物件會被放進不同Bucket，而當它們被新增的時候，就會分別地被新增 (我估計Object Class背後會跑一次equals跟hashCode method去決定如何做deduplication)。</p><p>因此，總括而言，當你需要比較兩個物件的時候，而又是使用Hash-based物件，就要記得覆寫兩個方法。</p><p> </p><h3 id=參考資料>參考資料</h3><p><a href=http://users.csc.calpoly.edu/~gfisher/classes/102/info/howToOverrideEquals.html>CPE102 - How and why to override the equals method in Java&mldr;</a></p><p><a href=https://howtodoinjava.com/java/basics/java-hashcode-equals-methods/>Java hashCode() and equals() – Contract, rules and best practices</a></p><p><a href=https://www.techiedelight.com/why-override-equals-and-hashcode-methods-java/>Why do we need to override equals and hashcode methods in Java?</a></p></div><div class=after-post-tags><ul class=tags><li><a href=/tags/java>java</a></li><li><a href=/tags/object>object</a></li><li><a href=/tags/override>override</a></li></ul></div><div class="row PageNavigation d-flex justify-content-between font-weight-bold"><a class="d-block col-md-6 text-lg-right" href=https://mattchannn.github.io/blog/2021-04/restful-api/>RESTful API 的前世今生 &#187;</a><div class=clearfix></div></div></div></div></div><div class=container><div id=comments class="row justify-content-center mb-5"><div class=col-md-8></div></div></div></div></div><footer class="page-footer text-center font-small mt-4 wow fadeIn"><div class="pb-2 mt-5 pt-4"><a href=https://github.com/mattchannn target=_blank rel=noopener><i class="fab fa-github mr-3" aria-hidden=true></i></a>
<a href=https://www.linkedin.com/in/mat-c-048371154/ target=_blank rel=noopener><i class="fab fa-linkedin-in mr-3" aria-hidden=true></i></a></div><div class="copyright pt-3 pb-4"><span>Copyright 2020 - 2021 &copy; <a href=https://github.com/mattchannn>Mat CHAN</a> | All Rights Reserved</span></div></footer></div><script src=https://code.jquery.com/jquery-3.4.1.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js integrity=sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut crossorigin=anonymous></script><script src=https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script><script src=/js/mediumish.js></script><script type=text/javascript src="https://s7.addthis.com/js/300/addthis_widget.js#pubid=ra-6081b0a845e416c0"></script></body></html>