<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blog on Mat's Blog</title><link>https://mattchannn.github.io/blog/</link><description>Recent content in Blog on Mat's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Mat - All rights reserved</copyright><lastBuildDate>Fri, 26 Mar 2021 11:12:00 +0200</lastBuildDate><atom:link href="https://mattchannn.github.io/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>為何要override Objects的equals 和hashCode method</title><link>https://mattchannn.github.io/blog/2021-06/java-object-equals-hashcode/</link><pubDate>Tue, 01 Jun 2021 18:00:00 +0800</pubDate><guid>https://mattchannn.github.io/blog/2021-06/java-object-equals-hashcode/</guid><description>為何要override Objects的equals 和hashCode method 你可曾有想過 在建構新class 新object的時候，為何我們要覆寫(override) Java/Lang/Object 中的equals 和hashCode方法(method)?
在開始之前，我們必先知道原本的方法是在實現什麼東西。
Equals // Java Lang Object public boolean equals(Object obj) { return (this == obj); } Equals會將兩個object的memory address比較， 如果相等， 回傳true。 簡單來說，當你instantiate 兩個不同object的時候， 儘管它們的數值一樣，該方法都會回傳false。</description></item><item><title>RESTful API 的前世今生</title><link>https://mattchannn.github.io/blog/2021-04/restful-api/</link><pubDate>Sat, 24 Apr 2021 12:00:04 +0800</pubDate><guid>https://mattchannn.github.io/blog/2021-04/restful-api/</guid><description>RESTful (Representational State Transfer) API 從1990到現在2021年，HTTP協定跟Web的架構已經與日俱增，當中最為人熟悉的為Roy Fielding所提出的一套理論框架。 在本文開始之前，編者強烈大家先看一下Roy Fielding的論文。
建設RESTful API 架設RESTful API之前，就先要符合以下6大規範(constraints)
需跟隨 客戶端/服務器 架構 client server 就是實現Separation of Concerns的最佳例子 user interface concern vs data storage concern 客戶端 (client)，請求服務 (perform service) 服務器 (server)，提供服務 (offer a set of services) 無狀態 (stateless) 這代表Client跟Server都不會記得之前的狀態 每個新的request都是獨立的 可緩存性 (cacheable) 緩存 (cache)，為一種暫時性的資料儲存方式 遵循此規範的就必須具有設定緩存的靈活度 分層系統 (layered system) REST讓我們在分層系統架構中能使用不同的 層 去進行活動 例如: 在presentation layer呈現U.</description></item><item><title>淺談null跟undefined</title><link>https://mattchannn.github.io/blog/2021-04/null-undefined/</link><pubDate>Wed, 21 Apr 2021 11:17:14 +0200</pubDate><guid>https://mattchannn.github.io/blog/2021-04/null-undefined/</guid><description>Null跟Undefined的對決 今天想跟大家聊聊javascript的null跟undefined，相信各位在開發時少不免都會遇到它們。第一眼看它們確實是挺相似的，但實際上它們有著以下的分別。
Undefined 代表 變數被定義但沒被指派 任何值 為 一種 類型 (type) 為 原始值 (primitive value) 為 假值 (falsy value) let newVar; console.log(newVar); // undefined Null 為 一個 物件 (object) 是 空/不存在的 值 是assignment value (需要被指派的) 是用以宣告newVar是沒有值的 為 假值 (falsy value) let newVar = null; console.</description></item><item><title>Git Message 如何做好 Version Control</title><link>https://mattchannn.github.io/blog/2021-04/git-message-control/</link><pubDate>Thu, 15 Apr 2021 11:17:14 +0200</pubDate><guid>https://mattchannn.github.io/blog/2021-04/git-message-control/</guid><description>如何做好Message Control Update, Minor Update, Fix&amp;hellip; 這個就是我工作時看到commit message的日常。然而，一個有水準的軟件工程師，除了代碼要寫的好，也要讓將來接替你位置的人，看得懂你的遺產，避免造成太多技術負債。
根據國外AngularJS團隊所提出的Git Commit Message Convention，commit message的格式如下：
Header: &amp;lt;commit type&amp;gt;(&amp;lt;scope&amp;gt;): &amp;lt;subject&amp;gt; &amp;lt;BLANK LINE&amp;gt; Body: &amp;lt;BLANK LINE&amp;gt; Footer: 請注意 所有git commit message都不能超過100個字元，因為是為了讓git使用者可以更容易看懂你的commit。  規範 首先從Header說起，commit type可以分為數項</description></item></channel></rss>