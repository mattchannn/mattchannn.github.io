<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>override on Mat's Blog</title><link>https://mattchannn.github.io/tags/override/</link><description>Recent content in override on Mat's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Mat - All rights reserved</copyright><lastBuildDate>Tue, 01 Jun 2021 18:00:00 +0800</lastBuildDate><atom:link href="https://mattchannn.github.io/tags/override/index.xml" rel="self" type="application/rss+xml"/><item><title>為何要override Objects的equals 和hashCode method</title><link>https://mattchannn.github.io/blog/2021-06/java-object-equals-hashcode/</link><pubDate>Tue, 01 Jun 2021 18:00:00 +0800</pubDate><guid>https://mattchannn.github.io/blog/2021-06/java-object-equals-hashcode/</guid><description>為何要override Objects的equals 和hashCode method 你可曾有想過 在建構新class 新object的時候，為何我們要覆寫(override) Java/Lang/Object 中的equals 和hashCode方法(method)?
在開始之前，我們必先知道原本的方法是在實現什麼東西。
Equals // Java Lang Object public boolean equals(Object obj) { return (this == obj); } Equals會將兩個object的memory address比較， 如果相等， 回傳true。 簡單來說，當你instantiate 兩個不同object的時候， 儘管它們的數值一樣，該方法都會回傳false。</description></item></channel></rss>